import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import * as os from 'os';

class MyTreeDataProvider implements vscode.TreeDataProvider<vscode.TreeItem> {
  private _onDidChangeTreeData: vscode.EventEmitter<vscode.TreeItem | undefined> = new vscode.EventEmitter<vscode.TreeItem | undefined>();
  readonly onDidChangeTreeData: vscode.Event<vscode.TreeItem | undefined> = this._onDidChangeTreeData.event;
  private lastErrorFilePath = path.join(os.homedir(), 'AppData', 'Local', 'Katerina Engine', 'scenario_errors.txt');

  constructor(private context: vscode.ExtensionContext) {}

  getTreeItem(element: vscode.TreeItem): vscode.TreeItem {
    return element;
  }

  getChildren(element?: vscode.TreeItem): vscode.ProviderResult<vscode.TreeItem[]> {
    const items: vscode.TreeItem[] = [];

    const config = vscode.workspace.getConfiguration('configs');
    const rootFolder = config.get<string>('vic2_root_folder');
    
    const runButton = new vscode.TreeItem('Run KatEngine Validation', vscode.TreeItemCollapsibleState.None);
    runButton.command = {
      command: 'extension.openFileSelection',
      title: 'Select .mod files'
    };
    runButton.tooltip = 'Click to select .mod files and validate them.';
    runButton.iconPath = new vscode.ThemeIcon('play');
    items.push(runButton);

    const openLastErrorButton = new vscode.TreeItem('Open Last Error File', vscode.TreeItemCollapsibleState.None);
    openLastErrorButton.command = {
      command: 'extension.openLastErrorFile',
      title: 'Open the last Error Log generated by Kate\'s Engine Validator'
    };
    openLastErrorButton.iconPath = new vscode.ThemeIcon('code-oss');
    items.push(openLastErrorButton);

    const openConfigButton = new vscode.TreeItem('Open Extension Settings', vscode.TreeItemCollapsibleState.None);
    openConfigButton.command = {
      command: 'workbench.action.openSettings',
      arguments: ['configs.vic2_root_folder'], // Opens the specific setting
      title: 'Open Extension Settings'
    };
    openConfigButton.tooltip = 'Click to configure the extension settings.';
    openConfigButton.iconPath = new vscode.ThemeIcon('gear'); // Uses the gear icon for settings
    items.push(openConfigButton);

    return Promise.resolve(items);
  }

  refresh(): void {
    this._onDidChangeTreeData.fire(undefined);
  }

  setLastErrorFilePath(filePath: string): void {
    this.lastErrorFilePath = filePath;
    this.refresh(); // Refresh to ensure UI reflects changes
  }

  getLastErrorFilePath(): string | undefined {
    return this.lastErrorFilePath;
  }
}

async function deleteAndOpenFile(scenarioErrorsPath: string, treeDataProvider: MyTreeDataProvider): Promise<void> {
  return vscode.window.withProgress({
    location: vscode.ProgressLocation.Notification,
    title: 'Validating... This can take a minute.',
    cancellable: false
  }, async (progress) => {
    try {
      await new Promise<void>((resolve, reject) => {
        fs.unlink(scenarioErrorsPath, (unlinkErr) => {
          if (unlinkErr && unlinkErr.code !== 'ENOENT') {
            vscode.window.showErrorMessage('Error deleting scenario_errors.txt.');
            reject(unlinkErr);
            return;
          }
          checkFileExistence(scenarioErrorsPath, resolve, reject, progress, treeDataProvider);
        });
      });

      // Open the file automatically after validation is complete
      const lastErrorFilePath = treeDataProvider.getLastErrorFilePath();
      if (lastErrorFilePath) {
        vscode.workspace.openTextDocument(lastErrorFilePath)
          .then(doc => vscode.window.showTextDocument(doc));
      } else {
        vscode.window.showErrorMessage('No error file found to open.');
      }
      
    } catch (error) {
      vscode.window.showErrorMessage(`Error during validation: ${(error as Error).message}`);
    }
  });
}

async function checkFileExistence(
  scenarioErrorsPath: string,
  resolve: () => void,
  reject: (error: Error) => void,
  progress: vscode.Progress<{ message?: string }>,
  treeDataProvider: MyTreeDataProvider
): Promise<void> {
  const timeoutDuration = 5 * 60 * 1000; // 5 minutes in milliseconds
  const startTime = Date.now();

  const checkAccess = (): Promise<void> => {
    return new Promise((innerResolve, innerReject) => {
      fs.access(scenarioErrorsPath, fs.constants.F_OK, (accessErr) => {
        if (!accessErr) {
          // Read the file content
          fs.readFile(scenarioErrorsPath, 'utf8', (readErr, data) => {
            if (readErr) {
              innerReject(readErr);
            } else {
              // Update the tree view with the file content
              treeDataProvider.setLastErrorFilePath(scenarioErrorsPath);
              innerResolve();
            }
          });
        } else {
          innerReject(new Error('File not accessible'));
        }
      });
    });
  };

  while (true) {
    try {
      await checkAccess();
      resolve();
      break; // Exit loop if the file is successfully read and displayed
    } catch (error) {
      // Check if the timeout duration has been exceeded
      if (Date.now() - startTime > timeoutDuration) {
        vscode.window.showErrorMessage('Timeout exceeded while waiting for the error log file.');
        reject(new Error('Timeout exceeded'));
        break;
      }

      progress.report({ message: '' });
      await new Promise(resolve => setTimeout(resolve, 1000)); // Retry after 1 second
    }
  }
}



export function activate(context: vscode.ExtensionContext) {
  const treeDataProvider = new MyTreeDataProvider(context);
  context.subscriptions.push(
    vscode.window.registerTreeDataProvider('victorian_tools', treeDataProvider),
    vscode.commands.registerCommand('extension.openFileSelection', async () => {
      const config = vscode.workspace.getConfiguration('configs');
      const vic2RootFolder = config.get<string>('vic2_root_folder');
      if (!vic2RootFolder) {
        vscode.window.showErrorMessage('No root folder configured in the settings.');
        return;
      }

      const modFolderPath = path.join(vic2RootFolder, 'mod');
      const mods = await fs.promises.readdir(modFolderPath);
      const modFiles = mods.filter(file => file.endsWith('.mod'));

      if (modFiles.length === 0) {
        vscode.window.showInformationMessage('No .mod files found in the mod folder.');
        return;
      }

      const selectedMods = await vscode.window.showQuickPick(modFiles, {
        placeHolder: 'Select .mod files to validate',
        canPickMany: true
      });
      if (!selectedMods) {
        return;
      }

      const fsPromises = fs.promises;

      const katEnginePath = path.join(vic2RootFolder, 'KatEngine.exe');
      const scenarioErrorsPath = path.join(os.homedir(), 'AppData', 'Local', 'Katerina Engine', 'scenario_errors.txt');
      
      try {
        await fsPromises.access(katEnginePath, fs.constants.F_OK);
      } catch (error) {
        vscode.window.showErrorMessage(
          'KatEngine.exe not found in the selected folder.',
          'Download Katerina Engine',
          'OK'
        ).then((selection?: string) => {
          if (selection === 'Download Katerina Engine') {
            vscode.env.openExternal(vscode.Uri.parse('https://github.com/Nivaturimika/Katerina-Engine/tree/0.0.11'));
          }
        });
        return;
      }

      const terminal = vscode.window.createTerminal('KatEngine Validation');
      terminal.show();
      terminal.sendText(`cd "${vic2RootFolder}"`);
      terminal.sendText(`.\\KatEngine.exe -validate -mod ${selectedMods.join(' ')}`);

      deleteAndOpenFile(scenarioErrorsPath, treeDataProvider);
    }),

    vscode.commands.registerCommand('extension.openLastErrorFile', () => {
      const lastErrorFilePath = treeDataProvider.getLastErrorFilePath();
      if (!lastErrorFilePath) {
        vscode.window.showErrorMessage('No error file to open.');
        return;
      }
      vscode.workspace.openTextDocument(lastErrorFilePath)
        .then(doc => vscode.window.showTextDocument(doc));
    })
  );

  var modifier = false;

  const hoverModifiers = vscode.languages.registerHoverProvider({ scheme: 'file', language: 'paradox' }, {
    provideHover(document, position, token) {
        console.log('Hovering over for modifiers: ', position);

        // Regex to match `has_country_modifier = something`, `remove_country_modifier = something`, or `add_country_modifier = { name = something }`
        const range = document.getWordRangeAtPosition(position, /\b(has_country_modifier|remove_country_modifier|add_country_modifier\s*=\s*{[^}]*name)\s*=\s*["']?[\w-]+["']?/);

        if (range) {
            console.log("Matched modifier regex");
            const text = document.getText(range);
            let modifierName;

            if (text.startsWith('add_country_modifier')) {
                const match = text.match(/name\s*=\s*["']?([\w-]+)["']?/);
                if (match) {
                    modifierName = match[1];
                }
            } else {
                modifierName = text.split('=')[1].trim().replace(/['"]+/g, '');
            }

            if (modifierName) {
                // Get the path of the current file and construct the common/modifiers.txt path
                const currentFilePath = document.uri.fsPath;
                const modifiersFilePath = path.join(path.dirname(currentFilePath), '../common/event_modifiers.txt');

                console.log('modifiersFilePath: ', modifiersFilePath);

                // Read and search the modifiers.txt file
                if (fs.existsSync(modifiersFilePath)) {
                    console.log("Modifiers file found");
                    const fileContent = fs.readFileSync(modifiersFilePath, 'utf-8');
                    
                    // Regex to find the modifier block in the format `modifierName = { ... }`
                    const modifierRegex = new RegExp(`${modifierName}\\s*=\\s*{([^}]*)}`, 's');
                    const match = modifierRegex.exec(fileContent);
                    if (match && match[1]) {
                        // Extract the contents of the modifier block
                        const modifierContent = match[1].trim().split('\n').map(line => line.trim()).filter(line => line.length > 0);
                        if (modifierContent.length > 0) {
                            // Display the modifier content in the hover tooltip
                            const markdown = new vscode.MarkdownString(`**Modifier:** ${modifierName}\n\n**Contents:**\n${modifierContent.join('\n')}`);
                            modifier = true;
                            return new vscode.Hover(markdown);
                        }
                    }
                }
            }
        }
        return null;
    }
  });

  context.subscriptions.push(hoverModifiers);

  const clickModifierProvider = vscode.languages.registerDefinitionProvider({ scheme: 'file', language: 'paradox' }, {
    provideDefinition(document, position, token) {
        const range = document.getWordRangeAtPosition(position, /\b(has_country_modifier|remove_country_modifier|add_country_modifier\s*=\s*{[^}]*name)\s*=\s*["']?[\w-]+["']?/);
        if (range) {
            const text = document.getText(range);
            let modifierName;

            if (text.startsWith('add_country_modifier')) {
                const match = text.match(/name\s*=\s*["']?([\w-]+)["']?/);
                if (match) {
                    modifierName = match[1];
                }
            } else {
                modifierName = text.split('=')[1].trim().replace(/['"]+/g, '');
            }

            if (modifierName) {
                const currentFilePath = document.uri.fsPath;
                const modifiersFilePath = path.join(path.dirname(currentFilePath), '../common/event_modifiers.txt');

                if (fs.existsSync(modifiersFilePath)) {
                    const fileContent = fs.readFileSync(modifiersFilePath, 'utf-8');
                    const lines = fileContent.split('\n');
                    for (let i = 0; i < lines.length; i++) {
                        if (lines[i].includes(`${modifierName} =`)) {
                            const uri = vscode.Uri.file(modifiersFilePath);
                            const position = new vscode.Position(i, 0);
                            modifier = true;
                            return new vscode.Location(uri, position);
                        }
                    }
                }
            }
        }
        return null;
    }
  });
  
  context.subscriptions.push(clickModifierProvider);

  const hoverLoc = vscode.languages.registerHoverProvider({ scheme: 'file', language: 'paradox' }, {
    provideHover(document, position, token) {
      console.log('Hovering over: ', position);
      if (modifier) { return null; };
  
      // Updated regex to match title, desc, or name with or without quotes
      const range = document.getWordRangeAtPosition(position, /\b(has_country_modifier|remove_country_modifier|title|desc|name|news_desc_short|news_desc_medium|news_desc_long)\s*=\s*["']?[\w-]+["']?/);
  
      if (range) {
        console.log("Matched regex");
        const text = document.getText(range);
        if (/^(title|desc|name|news_desc_short|news_desc_medium|news_desc_long)\s*=/.test(text)) {
          // Extract the key type (title, desc, name) and the value, removing any quotes
          const [keyType, key] = text.split('=').map(part => part.trim().replace(/['"]+/g, ''));
  
          // Get the path of the current file and construct the localization folder path
          const currentFilePath = document.uri.fsPath;
          const localizationPath = path.join(path.dirname(currentFilePath), '../localisation');
  
          console.log('localizationPath: ', localizationPath);
  
          // Read and search all CSV files in the localization folder
          if (fs.existsSync(localizationPath)) {
            console.log("Loc path found");
            const files = fs.readdirSync(localizationPath).filter(file => file.endsWith('.csv'));
            console.log(files[0]);
            for (const file of files) {
              const filePath = path.join(localizationPath, file);
              const fileContent = fs.readFileSync(filePath, 'utf-8');
              const lines = fileContent.split('\n');
              for (const line of lines) {
                const [csvKey, csvValue] = line.split(';');
                if (csvKey === key) {
                  // Display the matching line in the hover tooltip
                  const markdown = new vscode.MarkdownString(`${csvValue}`);
                  console.log(`Found localization for ${keyType}: `, key);
                  return new vscode.Hover(markdown);
                }
              }
            }
          }
        }
      }
      return null;
    }
  });
  
  context.subscriptions.push(hoverLoc);

  const clickLoc = vscode.languages.registerDefinitionProvider({ scheme: 'file', language: 'paradox' }, {
    provideDefinition(document, position, token) {
      if (modifier) { return null; };

      const range = document.getWordRangeAtPosition(position, /\b(has_country_modifier|remove_country_modifiertitle|desc|name|news_desc_short|news_desc_medium|news_desc_long)\s*=\s*["']?[\w-]+["']?/);
      
      if (range) {
        const text = document.getText(range);
        const key = text.split('=')[1].trim().replace(/['"]+/g, '');
  
        const currentFilePath = document.uri.fsPath;
        const localizationPath = path.join(path.dirname(currentFilePath), '../localisation');
  
        if (fs.existsSync(localizationPath)) {
          const files = fs.readdirSync(localizationPath).filter(file => file.endsWith('.csv'));
  
          for (const file of files) {
            const filePath = path.join(localizationPath, file);
            const fileContent = fs.readFileSync(filePath, 'utf-8');
            const lines = fileContent.split('\n');
  
            for (let i = 0; i < lines.length; i++) {
              const [csvKey] = lines[i].split(';');
              if (csvKey === key) {
                const targetUri = vscode.Uri.file(filePath);
                const targetPosition = new vscode.Position(i, 0);
                return new vscode.Location(targetUri, targetPosition);
              }
            }
          }
        }
      }
      return null;
    }
  });
  
  context.subscriptions.push(clickLoc);

  const hoverProviderTagLoc = vscode.languages.registerHoverProvider({ scheme: 'file', language: 'paradox' }, {
    provideHover(document, position, token) {
      console.log('Hovering over: ', position); 
      // Updated regex to match title, desc, or name with or without quotes
      const range = document.getWordRangeAtPosition(position, /[A-Z0-9]{3}/);
  
      if (range) {
        console.log("Matched regex");
        const text = document.getText(range);
        if (text != "AND") {
  
          // Get the path of the current file and construct the localization folder path
          const currentFilePath = document.uri.fsPath;
          const localizationPath = path.join(path.dirname(currentFilePath), '../localisation');
  
          console.log('localizationPath: ', localizationPath);
  
          // Read and search all CSV files in the localization folder
          if (fs.existsSync(localizationPath)) {
            console.log("Loc path found");
            const files = fs.readdirSync(localizationPath).filter(file => file.endsWith('.csv'));
            console.log(files[0]);
            for (const file of files) {
              const filePath = path.join(localizationPath, file);
              const fileContent = fs.readFileSync(filePath, 'utf-8');
              const lines = fileContent.split('\n');
              for (const line of lines) {
                const [csvKey, csvValue] = line.split(';');
                if (csvKey === text) {
                  // Display the matching line in the hover tooltip
                  const markdown = new vscode.MarkdownString(`${csvValue}`);
                  console.log(`Found localization for ${text}: `, text);
                  return new vscode.Hover(markdown);
                }
              }
            }
          }
        }
      }
      return null;
    }
  });
  
  context.subscriptions.push(hoverProviderTagLoc);

  const clickTagProvider = vscode.languages.registerDefinitionProvider({ scheme: 'file', language: 'paradox' }, {
    provideDefinition(document, position, token) {
        // Match any 3 uppercase letters or digits
        const range = document.getWordRangeAtPosition(position, /[A-Z0-9]{3}/);

        if (range) {
            const text = document.getText(range);
            if (text !== "AND") {
                // Get the path of the current file and construct the history/country folder path
                const currentFilePath = document.uri.fsPath;
                const historyCountryPath = path.join(path.dirname(currentFilePath), '../history/countries');

                if (fs.existsSync(historyCountryPath)) {
                    const files = fs.readdirSync(historyCountryPath).filter(file => file.startsWith(text));
                    
                    if (files.length > 0) {
                        const filePath = path.join(historyCountryPath, files[0]);

                        const uri = vscode.Uri.file(filePath);
                        const position = new vscode.Position(0, 0); // Start at the beginning of the file
                        return new vscode.Location(uri, position);
                    }
                }
            }
        }
        return null;
    }
  });

  context.subscriptions.push(clickTagProvider);

}

export function deactivate() {}

