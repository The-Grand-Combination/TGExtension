import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import * as os from 'os';

class MyTreeDataProvider implements vscode.TreeDataProvider<vscode.TreeItem> {
  private _onDidChangeTreeData: vscode.EventEmitter<vscode.TreeItem | undefined> = new vscode.EventEmitter<vscode.TreeItem | undefined>();
  readonly onDidChangeTreeData: vscode.Event<vscode.TreeItem | undefined> = this._onDidChangeTreeData.event;
  private lastErrorFilePath = path.join(os.homedir(), 'AppData', 'Local', 'Katerina Engine', 'scenario_errors.txt');

  constructor(private context: vscode.ExtensionContext) {}

  getTreeItem(element: vscode.TreeItem): vscode.TreeItem {
    return element;
  }

  getChildren(element?: vscode.TreeItem): vscode.ProviderResult<vscode.TreeItem[]> {
    const items: vscode.TreeItem[] = [];

    const config = vscode.workspace.getConfiguration('configs');
    const rootFolder = config.get<string>('vic2_root_folder');
    
    const runButton = new vscode.TreeItem('Run KatEngine Validation', vscode.TreeItemCollapsibleState.None);
    runButton.command = {
      command: 'extension.openFileSelection',
      title: 'Select .mod files'
    };
    runButton.tooltip = 'Click to select .mod files and validate them.';
    runButton.iconPath = new vscode.ThemeIcon('debug-alt');
    items.push(runButton);

    const openLastErrorButton = new vscode.TreeItem('Open Last Error File', vscode.TreeItemCollapsibleState.None);
    openLastErrorButton.command = {
      command: 'extension.openLastErrorFile',
      title: 'Open the last Error Log generated by Kate\'s Engine Validator'
    };
    openLastErrorButton.iconPath = new vscode.ThemeIcon('code-oss');
    items.push(openLastErrorButton);

    const launchGameButton = new vscode.TreeItem('Launch Game', vscode.TreeItemCollapsibleState.None);
    launchGameButton.command = {
      command: 'extension.launchGame',
      title: 'Pick mods and launch game'
    };
    launchGameButton.iconPath = new vscode.ThemeIcon('play');
    items.push(launchGameButton);

    const openConfigButton = new vscode.TreeItem('Open Extension Settings', vscode.TreeItemCollapsibleState.None);
    openConfigButton.command = {
      command: 'workbench.action.openSettings',
      arguments: ['configs.vic2_root_folder'],
      title: 'Open Extension Settings'
    };
    openConfigButton.tooltip = 'Click to configure the extension settings.';
    openConfigButton.iconPath = new vscode.ThemeIcon('gear');
    items.push(openConfigButton);

    return Promise.resolve(items);
  }

  refresh(): void {
    this._onDidChangeTreeData.fire(undefined);
  }

  setLastErrorFilePath(filePath: string): void {
    this.lastErrorFilePath = filePath;
    this.refresh();
  }

  getLastErrorFilePath(): string | undefined {
    return this.lastErrorFilePath;
  }
}

async function deleteAndOpenFile(scenarioErrorsPath: string, treeDataProvider: MyTreeDataProvider): Promise<void> {
  return vscode.window.withProgress({
    location: vscode.ProgressLocation.Notification,
    title: 'Validating... This can take a minute.',
    cancellable: false
  }, async (progress) => {
    try {
      await new Promise<void>((resolve, reject) => {
        fs.unlink(scenarioErrorsPath, (unlinkErr) => {
          if (unlinkErr && unlinkErr.code !== 'ENOENT') {
            vscode.window.showErrorMessage('Error deleting scenario_errors.txt.');
            reject(unlinkErr);
            return;
          }
          checkFileExistence(scenarioErrorsPath, resolve, reject, progress, treeDataProvider);
        });
      });

      // Open the file automatically after validation is complete
      const lastErrorFilePath = treeDataProvider.getLastErrorFilePath();
      if (lastErrorFilePath) {
        vscode.workspace.openTextDocument(lastErrorFilePath)
          .then(doc => vscode.window.showTextDocument(doc));
      } else {
        vscode.window.showErrorMessage('No error file found to open.');
      }
      
    } catch (error) {
      vscode.window.showErrorMessage(`Error during validation: ${(error as Error).message}`);
    }
  });
}

async function checkFileExistence(
  scenarioErrorsPath: string,
  resolve: () => void,
  reject: (error: Error) => void,
  progress: vscode.Progress<{ message?: string }>,
  treeDataProvider: MyTreeDataProvider
): Promise<void> {
  const timeoutDuration = 5 * 60 * 1000; // 5 minutes in milliseconds
  const startTime = Date.now();

  const checkAccess = (): Promise<void> => {
    return new Promise((innerResolve, innerReject) => {
      fs.access(scenarioErrorsPath, fs.constants.F_OK, (accessErr) => {
        if (!accessErr) {
          // Read the file content
          fs.readFile(scenarioErrorsPath, 'utf8', (readErr, data) => {
            if (readErr) {
              innerReject(readErr);
            } else {
              // Update the tree view with the file content
              treeDataProvider.setLastErrorFilePath(scenarioErrorsPath);
              innerResolve();
            }
          });
        } else {
          innerReject(new Error('File not accessible'));
        }
      });
    });
  };

  while (true) {
    try {
      await checkAccess();
      resolve();
      break; // Exit loop if the file is successfully read and displayed
    } catch (error) {
      // Check if the timeout duration has been exceeded
      if (Date.now() - startTime > timeoutDuration) {
        vscode.window.showErrorMessage('Timeout exceeded while waiting for the error log file.');
        reject(new Error('Timeout exceeded'));
        break;
      }

      progress.report({ message: '' });
      await new Promise(resolve => setTimeout(resolve, 1000)); // Retry after 1 second
    }
  }
}



export function activate(context: vscode.ExtensionContext) {
  const treeDataProvider = new MyTreeDataProvider(context);
  context.subscriptions.push(
    vscode.window.registerTreeDataProvider('victorian_tools', treeDataProvider),
    vscode.commands.registerCommand('extension.openFileSelection', async () => {
      const config = vscode.workspace.getConfiguration('configs');
      const vic2RootFolder = config.get<string>('vic2_root_folder');
      if (!vic2RootFolder) {
        vscode.window.showErrorMessage('No root folder configured in the settings.');
        return;
      }

      const modFolderPath = path.join(vic2RootFolder, 'mod');
      const mods = await fs.promises.readdir(modFolderPath);
      const modFiles = mods.filter(file => file.endsWith('.mod'));

      if (modFiles.length === 0) {
        vscode.window.showInformationMessage('No .mod files found in the mod folder.');
        return;
      }

      const selectedMods = await vscode.window.showQuickPick(modFiles, {
        placeHolder: 'Select .mod files to validate',
        canPickMany: true
      });
      if (!selectedMods) {
        return;
      }

      const fsPromises = fs.promises;

      const katEnginePath = path.join(vic2RootFolder, 'KatEngine.exe');
      const scenarioErrorsPath = path.join(os.homedir(), 'AppData', 'Local', 'Katerina Engine', 'scenario_errors.txt');
      
      try {
        await fsPromises.access(katEnginePath, fs.constants.F_OK);
      } catch (error) {
        vscode.window.showErrorMessage(
          'KatEngine.exe not found in the selected folder.',
          'Download Katerina Engine',
          'OK'
        ).then((selection?: string) => {
          if (selection === 'Download Katerina Engine') {
            vscode.env.openExternal(vscode.Uri.parse('https://github.com/Nivaturimika/Katerina-Engine/tree/0.0.11'));
          }
        });
        return;
      }

      const terminal = vscode.window.createTerminal('KatEngine Validation');
      terminal.show();
      terminal.sendText(`cd "${vic2RootFolder}"`);
      terminal.sendText(`.\\KatEngine.exe -validate -mod ${selectedMods.join(' ')}`);

      deleteAndOpenFile(scenarioErrorsPath, treeDataProvider);
    }),

    vscode.commands.registerCommand('extension.openLastErrorFile', () => {
      const lastErrorFilePath = treeDataProvider.getLastErrorFilePath();
      if (!lastErrorFilePath) {
        vscode.window.showErrorMessage('No error file to open.');
        return;
      }
      vscode.workspace.openTextDocument(lastErrorFilePath)
        .then(doc => vscode.window.showTextDocument(doc));
    }),

    vscode.commands.registerCommand('extension.launchGame', async () => {
      const config = vscode.workspace.getConfiguration('configs');
      const vic2RootFolder = config.get<string>('vic2_root_folder');
      if (!vic2RootFolder) {
        vscode.window.showErrorMessage('No root folder configured in the settings.');
        return;
      }

      const modFolderPath = path.join(vic2RootFolder, 'mod');
      const mods = await fs.promises.readdir(modFolderPath);
      const modFiles = mods.filter(file => file.endsWith('.mod'));

      if (modFiles.length === 0) {
        vscode.window.showInformationMessage('No .mod files found in the mod folder.');
        return;
      }

      const selectedMods = await vscode.window.showQuickPick(modFiles, {
        placeHolder: 'Select .mod files to run.',
        canPickMany: true
      });
      if (!selectedMods) {
        return;
      }

      const fsPromises = fs.promises;

      const gamepath = path.join(vic2RootFolder, 'v2game.exe');
      
      try {
        await fsPromises.access(gamepath, fs.constants.F_OK);
      } catch (error) {
        vscode.window.showErrorMessage(
          'v2gamne.exe not found in the selected folder. Are you sure you got the correct root folder?',
          'OK'
        );
        return;
      }
      const modifiedMods = selectedMods.map(mod => `'-mod=mod/${mod}'`);
      const terminal = vscode.window.createTerminal('Game Launcher');
      terminal.show();
      terminal.sendText(`cd "${vic2RootFolder}"`);
      terminal.sendText(`.\\v2game.exe ${modifiedMods.join(' ')}`);

    })

  );

  var modifier = false;

  function searchLocation(text, document) {

      const currentFilePath = document.uri.fsPath;
      const localizationPath = path.join(path.dirname(currentFilePath), '../localisation');

      if (fs.existsSync(localizationPath)) {
        console.log("Loc path found");
        console.log("Searching for: " + text);
        const files = fs.readdirSync(localizationPath).filter(file => file.endsWith('.csv'));
        console.log(files[0]);
        for (const file of files) {
          const filePath = path.join(localizationPath, file);
          const fileContent = fs.readFileSync(filePath, 'utf-8');
          const lines = fileContent.split('\n');
          for (const line of lines) {
            const [csvKey, csvValue] = line.split(';');
            if (csvKey === text) {
              const markdown = new vscode.MarkdownString(`${csvValue}`);
              return new vscode.Hover(markdown);
            }
          }
        }
        const no_source = 'No Source Found.'
        const markdown = new vscode.MarkdownString(`${no_source}`);
        return new vscode.Hover(markdown);
      }
  }

  const hoverLoc = vscode.languages.registerHoverProvider({ scheme: 'file', language: 'paradox' }, {
    provideHover(document, position) {
      const regex = /\b(?:has_country_flag|clr_country_flag|add_country_flag|remove_country_modifier|add_country_modifier|title|desc|name|news_desc_short|news_desc_medium|news_desc_long)\s*=\s*["']?([\w-]+)["']?/
      const range = document.getWordRangeAtPosition(position, regex);
      const match = range ? document.getText(range).match(regex) : null;
      const text = match ? match[1] : null;
      return text ? searchLocation(text, document) : null;
    }

  });
  
  context.subscriptions.push(hoverLoc);

  const clickLoc = vscode.languages.registerDefinitionProvider({ scheme: 'file', language: 'paradox' }, {
    provideDefinition(document, position) {
      if (modifier) { return null; };

      const range = document.getWordRangeAtPosition(position, /\b(has_country_flag|clr_country_flag|add_country_flag|title|desc|name|news_desc_short|news_desc_medium|news_desc_long)\s*=\s*["']?[\w-]+["']?/);
      
      if (!range) { return null; }

      const key = document.getText(range).split('=')[1].trim().replace(/['"]+/g, '');
      const localizationPath = path.join(path.dirname(document.uri.fsPath), '../localisation');

      if (fs.existsSync(localizationPath)) {
        const files = fs.readdirSync(localizationPath).filter(file => file.endsWith('.csv'));

        let found = false;
        for (const file of files) {
          const filePath = path.join(localizationPath, file);
          const fileContent = fs.readFileSync(filePath, 'utf-8');
          const lines = fileContent.split('\n');

          for (let i = 0; i < lines.length; i++) {
            const [csvKey] = lines[i].split(';');
            if (csvKey === key) {
              const targetUri = vscode.Uri.file(filePath);
              const targetPosition = new vscode.Position(i, 0);
              return new vscode.Location(targetUri, targetPosition);
            }
          }
        }

        const targetFile = path.join(localizationPath, 'vt_localization.csv');
        if (!fs.existsSync(targetFile)) {
          const loc_code = 'CODE;ENGLISH;FRENCH;GERMAN;POLISH;SPANISH;ITALIAN;SWEDISH;CZECH;HUNGARIAN;DUTCH;PORTUGUESE;RUSSIAN;FINNISH;x\n';
          fs.writeFileSync(targetFile, loc_code);
        }

        const fileContent = fs.readFileSync(targetFile, 'utf-8');
        const lines = fileContent.split('\n');
        const targetUri = vscode.Uri.file(targetFile);
        const targetPosition = new vscode.Position(lines.length, 0);
        return new vscode.Location(targetUri, targetPosition);
        
      }
    }


  });
  
  context.subscriptions.push(clickLoc);

  const hoverTag = vscode.languages.registerHoverProvider({ scheme: 'file', language: 'paradox' }, {
    provideHover(document, position) {
      const regex = /\b(?!AND\b|NOT\b)[A-Z0-9]{3}\b/;
      const range = document.getWordRangeAtPosition(position, regex);
      const match = range ? document.getText(range).match(regex) : null;
      const text = match ? match[0] : null;
      return text ? searchLocation(text, document) : null;
    }
  });
  
  context.subscriptions.push(hoverTag);

  const clickTag = vscode.languages.registerDefinitionProvider({ scheme: 'file', language: 'paradox' }, {
    provideDefinition(document, position) {
      const regex = /\b(?!AND\b|NOT\b)[A-Z0-9]{3}\b/;
      const range = document.getWordRangeAtPosition(position, regex);
      const match = range ? document.getText(range).match(regex) : null;
      const text = match ? match[0] : null;
  
      if (text) {
        const currentFilePath = document.uri.fsPath;
        const parentDirectory = path.dirname(currentFilePath);
        const historyCountryPath = path.join(parentDirectory, '../history/countries');
  
        if (fs.existsSync(historyCountryPath)) {
          const files = fs.readdirSync(historyCountryPath).filter(file => file.startsWith(text));
          
          if (files.length > 0) {
            const filePath = path.join(historyCountryPath, files[0]);
            const uri = vscode.Uri.file(filePath);
            const position = new vscode.Position(0, 0);
            return new vscode.Location(uri, position);
          }
        }
      }
  
      return null;
    }
  });
  
  context.subscriptions.push(clickTag);
  
}

export function deactivate() {}

